/**
 * scroll-trigger v0.0.1
 * @author Vu Pham
 * @homepage https://github.com/vuquangpham/scroll-trigger
 * @license MIT 2023
 */
!function(t,e){if("object"==typeof exports&&"object"==typeof module)module.exports=e();else if("function"==typeof define&&define.amd)define([],e);else{var n=e();for(var o in n)("object"==typeof exports?exports:t)[o]=n[o]}}(this,(()=>(()=>{"use strict";var t={r:t=>{"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(t,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(t,"__esModule",{value:!0})}},e={};function n(){return(arguments.length>0&&void 0!==arguments[0]?arguments[0]:"")+Date.now().toString(36)+Math.random().toString(36).slice(2)}function o(){let t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{type:"div",attributes:[{key:"",value:""}],style:{},classes:[]},e=null;return e=t.namespace?document.createElementNS(t.namespace,t.type):document.createElement(t.type),t.attributes&&t.attributes.forEach((t=>e.setAttribute(t.key,t.value))),t.classes&&e.classList.add(...t.classes),Object.assign(e.style,t.style),e}function r(t){var e,n;t.markers&&(e={start:t.startPositionObject.viewport,end:t.endPositionObject.viewport},n={start:t.startPositionObject.trigger,end:t.endPositionObject.trigger,element:t.trigger},[e,n].forEach((t=>{const e=!t.element,n=o({type:"div",style:{position:e?"fixed":"absolute",top:0,left:0,right:0,bottom:0,pointerEvents:"none"}}),r={position:"absolute",right:0,width:"100px",height:"3px",fontSize:"14px"},i=o({type:"div",style:{top:t.start+"px",background:"green",color:"green",...r}});i.innerHTML=`<span>${e?"scroller-start":"start"}</span>`;const s=o({type:"div",style:{top:t.end+"px",right:0,background:"red",color:"red",transform:`translateY(${0===t.end?0:"-100%"})`,...r}});s.innerHTML=`<span style="transform:translateY(${0===t.end?0:"-100%"}); display:block;">${e?"scroller-end":"end"}</span>`,n.appendChild(i),n.appendChild(s);const l=e?document.body:t.element;"static"===getComputedStyle(l).position&&(l.style.position="relative"),l.appendChild(n)})))}t.r(e);const i=t=>t>=0&&t<=1,s=(t,e,n)=>{const o={trigger:t.trigger,progress:n,destroy:t.destroy};"function"==typeof t.onEnter&&e<0&&n>0&&t.onEnter(o),"function"==typeof t.onLeave&&n>1&&i(e)&&t.onLeave(o),"function"==typeof t.onUpdate&&i(n)&&e!==n&&t.onUpdate(o)},l={top:0,center:.5,bottom:1};function a(t){const{position:e,viewportHeight:n,triggerHeight:o}=t,r=e.split(" ");if(1===r.length||r.length>2)return null;const i={trigger:0,viewport:0};for(let t=0;t<r.length;t++){const e=r[t];let s=0;const a=0===t?o:n;s=l.hasOwnProperty(e)?l[e]*a:c(e,a);i[0===t?"trigger":"viewport"]=Math.min(s,a)}return i}const c=function(t){let e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return parseFloat(t)?t.includes("+=")&&t.split("+=").length>1?t.split("+=").reduce(((t,n)=>n.includes("%")?t+d(n,e):t+parseFloat(n)),0):t.includes("%")?d(t,e):parseFloat(t):null},d=function(t){let e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:window.innerHeight;return.01*parseFloat(t)*e};return window.ScrollTrigger=new class{constructor(){this.instances=[]}create(t){const e={id:n("st-"),trigger:null,start:"top top",end:"top bottom",timeout:null,markers:!1,onEnter:t=>{},onUpdate:t=>{},onLeave:t=>{},...t};if(e.trigger=function(t){let e="Target element not found! Please use correct DOM element!";return"string"==typeof t&&(t=document.querySelector(t),e="Target string is not valid! Please use correct CSS selector!"),t||(console.error(e),!1)}(e.trigger),!e.trigger)return;e.destroy=this.destroy.bind(this,e);const o=function(t){const e={viewportHeight:innerHeight,triggerHeight:t.trigger.getBoundingClientRect().height},n=a({position:t.start,...e}),o=a({position:t.end,...e});return n&&o?(t.startPositionObject=n,t.endPositionObject=o,!0):(console.error("Please fill in the start and end position or left it empty to get the default value!"),!1)}(e);if(!o)return null;const i=function(t){const e=t.startPositionObject.viewport,n=t.endPositionObject.viewport,o=t.startPositionObject.trigger,r=t.endPositionObject.trigger;let i=0,l=!0;const a=()=>{const c=t.trigger.getBoundingClientRect(),d=e-(c.top+o),g=r-o-(n-e);if(g<0)return l=!1,void console.warn("Available area of trigger element is shorter than the viewport!");const p=0===g&&0===d?1:d/g;s(t,i,p),i=p,!0!==t.destroy&&(t.timeout=requestAnimationFrame(a))};return a(),l}(e);return i?(this.instances.push(e),r(e),{id:e.id,trigger:e.trigger,destroy:e.destroy}):null}get(t){return this.instances.find((e=>e.id===t))}destroy(t){const e=e=>e.id===t.id,n=this.instances.find(e);if(n){const o=this.instances.findIndex(e);return t.destroy=!0,cancelAnimationFrame(n.timeout),this.instances.splice(o,1),!0}return!1}},e})()));